import { GameState, lastIndex } from './state.js'; import { drawFrom, showCard } from './cards.js'; import { Effects } from './effects/index.js';
export const Engine={ busy:false, waiting:false, pending:null }; window.Engine=Engine;
Engine.afterRoll=function(n){ if(Engine.busy||Engine.waiting) return; GameState.started=true; const p=GameState.players[GameState.activeIdx];
  Engine._moveSteps(p,n,async()=>{ const sp=GameState.board?.spaces?.[p.index]; const deck=sp&&sp.deck; if(deck){ const card=drawFrom(deck); if(card){ Engine.waiting=true; Engine.pending={pid:p.id,effect:String(card.effect||'').trim()}; showCard(deck,card); return; } } finalizeTurn(); }); };
Engine.onCardAcknowledged=async function(){ if(!Engine.pending){ finalizeTurn(); return;} const {pid,effect}=Engine.pending; Engine.pending=null; const p=GameState.players.find(x=>x.id===pid); Engine.waiting=false; if(p&&effect){ await Effects.apply(p,effect);} finalizeTurn(); };
Engine._moveSteps=function(player,steps,done){ Engine.busy=true; const per=steps>=0?1:-1; let remaining=Math.abs(steps);
  (function step(){ if(remaining<=0){ Engine.busy=false; window.renderTokens&&window.renderTokens(); done&&done(); return; } const nextIdx=Math.max(0,Math.min(player.index+per,lastIndex())); player.index=nextIdx; window.renderTokens&&window.renderTokens(); remaining-=1; setTimeout(step,250); })(); };
function nextActiveIdx(){ const n=GameState.players.length; let i=(GameState.activeIdx+1)%n; while(GameState.players[i].skipNext){ GameState.players[i].skipNext=false; i=(i+1)%n; } return i; }
function finalizeTurn(){ const p=GameState.players[GameState.activeIdx]; if(p.extraRoll){ p.extraRoll=false; return; } GameState.activeIdx=nextActiveIdx(); window.renderTokens&&window.renderTokens(); }