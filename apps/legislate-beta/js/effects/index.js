import { GameState, stageAt } from '../state.js';
export const Effects={ handlers:new Map(), register(id,fn){ this.handlers.set(id,fn); }, async apply(player,effect){ if(!effect) return; const e=String(effect).trim().toLowerCase(); let id=e,arg=null; const m=e.match(/^([a-z_]+)[: ](.+)$/); if(m){ id=m[1]; arg=m[2]; } const h=this.handlers.get(id); if(h){ await h(player,arg);} } };
Effects.register('miss_turn', async p=>{ p.skipNext=true; });
Effects.register('extra_roll', async p=>{ p.extraRoll=true; });
Effects.register('move', async (p,arg)=>{ const n=parseInt(arg||'0',10)||0; await window.Engine._moveSteps(p,n); });
Effects.register('move:start', async p=>{ p.index=0; window.renderTokens&&window.renderTokens(); });
Effects.register('move:end', async p=>{ p.index=(window.lastIndex?window.lastIndex():p.index); window.renderTokens&&window.renderTokens(); });
Effects.register('move:previous', async (p,stage)=>{ const spaces=GameState.board?.spaces||[]; for(let i=p.index-1;i>=0;i--){ if(spaces[i].stage===stage){ p.index=i; break; } } window.renderTokens&&window.renderTokens(); });
Effects.register('move:nearest', async (p,stage)=>{ const spaces=GameState.board?.spaces||[]; let idx=p.index; for(let i=p.index-1;i>=0;i--){ if(spaces[i].stage===stage){ idx=i; break; } } if(idx===p.index){ for(let i=p.index+1;i<spaces.length;i++){ if(spaces[i].stage===stage){ idx=i; break; } } } p.index=idx; window.renderTokens&&window.renderTokens(); });
Effects.register('pingpong', async p=>{ const s=stageAt(p.index); const order=['start','early','commons','lords','implementation','end']; const i=order.indexOf(s); const prev=i>0?order[i-1]:s; const spaces=GameState.board?.spaces||[]; for(let j=p.index-1;j>=0;j--){ if(spaces[j].stage===prev){ p.index=j; break;} } window.renderTokens&&window.renderTokens(); });